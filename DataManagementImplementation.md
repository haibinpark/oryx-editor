# Implementation #

This is an extract taken from my final bachelor's paper; Martin Czuchra. Oryx - Embedding Business Process Data into the Web. Final bachelorâ€™s paper, Hasso Plattner Institute at the University of Potsdam, July 2007.

# Data Access #

When discussing the data management of Oryx, there are a lot of implementation details that are important to both continuing the development of the editor and being able to access Oryx data from other applications running on the same page. While architectural and implementation details for the different modules of data management will be discussed later in this chapter and independently for each module, in this section, I will concentrate on giving an overview of the RDF triple as it is used in data management and the triple querying techniques available in Oryx. This section should be an entry-point for every developer interested in accessing Oryx' process data.

## The RDF Triple ##

Each RDF Triple consists of a subject, a predicate and an object. However, when using eRDF to store triples, there are certain constraints on the data types of both the subject and the object. The subject is always a resource, the object can be either resource or literal. Figure 1 shows an example of eRDF-annotated XHTML that results in the triples displayed in figure 2. Resources are by convention enclosed into angle brackets and literals into quotation marks. As you can see, only the first triple of figure 2 has a resource object, but all share the same resource subject. The two other triples both use literal objects.

```
<div id='oryx-activity1234'>

    <a href='./edit' rel='oryx-editurl' />

    <span class='oryx-name'>Parse eRDF</span>
    <span class='oryx-bounds'>20,20,120,80</span>
</div>
```
Figure 1: A simple eRDF sample.

```
<#oryx-activity1234> oryx:editurl <http://b3mn.org/resource/activity1234/edit>
<#oryx-activity1234> oryx:name 'Parse eRDF'
<#oryx-activity1234> oryx:bounds '20,20,120,80'
```
Figure 2: The triples produced by figure 1

### Internal Triple Representation ###

With respect to the triple characteristics described in "The RDF Triple", the internal data structure representing a triple was chosen to be a JavaScript object with at least the following fields: subject, predicate and object. Each subject and object have to know both a type and a value. The type may only be one of the following constants: `ERDF.RESOURCE` or `ERDF.LITERAL`. The value is always a JavaScript string that in case of a resource subject or object contains a URL, in every other case the plain literal string. The predicate, however, knows no type or value, but a prefix and name.

```
var triple = {
    subject: {type: ERDF.RESOURCE, value: '#oryx-activity1234'},
    predicate: {prefix: 'oryx', name: 'name'},
    object: {type: ERDF.LITERAL, value: 'Parse eRDF'}
};
```
Figure 3 The notation of a triple using JSON.

Figure 3 shows a simple example of a triple<sup>1</sup> created by usage of JSON, figure 4 shows the generation of an `rdf:type` triple as performed by the eRDF parser (see rule six in Body Metadata). When code readability is preferred over additional helper methods, use the JSON way to write triples, otherwise, and if you wish to further process the data, use the ERDF.Triple, ERDF.Resource and ERDF.Literal constructors instead.

```
var triple = new ERDF.Triple(
    (subjectType == ERDF.RESOURCE) ?
        new ERDF.Resource(subject) :
        new ERDF.Literal(subject),
    {prefix: 'rdf', name: 'type'},
    new ERDF.Resource(schema.namespace+property)
);
```
Figure 4: The generation of an `rdf:type` triple as performed by the eRDF parser.

### Complex Data Types ###

When describing object values that are not resources and also are not literals, such as numbers, or more complex data types like dates, one has to use literals in eRDF triple generation and accompany every such object with the following:
  * A resource URL, describing the location of the object value in order to make it possible to make new assertions on it.
  * A second triple whose subject is the resource URL of the object value, whose predicate is `rdf:type`, and a resource object referencing the appropriate data type in the XSD `[1] ` namespace (mostly by providing an XSD data type).

Changing the previous example to reflect the fact that the last triple has a complex data type object, namely `oryx:bounds-datatype`, would result in what is to see in figure 5. The triples generated by this XHTML snippet can be seen in figure 6.

This is the general approach when dealing with complex types in eRDF. However, to simplify triple manipulation and to avoid overhead in both the Oryx editor and the back end, the Oryx data management does not provide any more support for complex types other than the possibility to query for their name. Internally, all triples are stored with literal or resource objects. Whether any querying application respects the provided type information is in its responsibility only and fully optional. In fact, the Oryx editor expects all triple objects representing shape properties as described by the stencil set to be literals `[2]`.

```
<div id='oryx-activity1234'>

	<a href='./edit' rel='oryx-editurl' />

    <span class='oryx-name'>Parse eRDF</span>
    <span class='oryx-bounds -oryx-bounds-datatype'
          id='bounds345'>20,20,120,80</span>
</div>
```
Figure 5: An advanced eRDF sample.

```
<#oryx-activity1234> oryx:editurl
    <http://b3mn.org/resource/activity1234/edit>
<#oryx-activity1234> oryx:name 'Parse eRDF'
<#oryx-activity1234> oryx:bounds <#bounds345>
<#bounds345> rdf:type 'oryx:bounds-datatype'
```
Figure 6: The triples produced by figure 5.

## Querying Technique ##

There is a very simple way to access all triples from the Oryx data management. The editor knows a public object named DataManager, that itself knows a method named query(). The actions performed internally cause the data manager to access the triple store to find all matching triples. To learn more about the triple store, see Triple Store.

```
query: function(subject, predicate, object) {

    /*
     * Typical triple.
     *	{value: subject, type: subjectType},
     *	{prefix: schema.prefix, name: property},
     *	{value: object, type: objectType});
     */	

    return DataManager._triples.select(function(triple) {

        var select = ((subject) ?
            (triple.subject.type == subject.type) &&
            (triple.subject.value == subject.value) : true);

        if(predicate) {
            select = select && ((predicate.prefix) ?
                (triple.predicate.prefix == predicate.prefix) : true);
            select = select && ((predicate.name) ?
                (triple.predicate.name == predicate.name) : true);
        }

        select = select && ((object) ?
            (triple.object.type == object.type) &&
            (triple.object.value == object.value) : true);
        return select;
    });
}
```
Figure 7: The query method of Oryx data management.

The query method as seen in 7 accepts three parameters. The first one is supposed to be a triple's subject, the second one a triple's predicate and the last one a triple's object, all of them in the style of a general triple as described in Triple Repository. Any of the parameters may be null or undefined. The query method identifies all triples known to the data manager which match the following rules:

  1. If a subject has been passed to the query method, this subject must equal the triple's subject in both the subject type and value.
  1. If a predicate has been passed to the query method, the prefix and name of the passed predicate must either be null or undefined, or they must equal the prefix and name of the triple's predicate, respectively<sup>2</sup>.
  1. If an object has been passed to the query method, this object must equal the triple's object in both the object type and value.

All triples matching these rules will be collected and returned in form of an array. Such a triple array might then be traversed using the each-method to perform an action on each data set.

Figure 8 shows the Oryx editor's initialization of all canvases. Therefore, the editor is querying all triples that have a resource object identifying the URL http://oryx-editor.org/canvas. Since the subject and the predicate are passed as undefined to the query method, they may be arbitrary in the returned triples. For each triple in the result, the function passed to the each-method is then called with c being the current triple. In this function, the queried triples are being analyzed and editor instances are spawned for each triple's subject.

```
DataManager.query(
    undefined,
    undefined,
    {type: ERDF.RESOURCE, value: 'http://oryx-editor.org/canvas'}).each(

        function(c) {
            var anchor = c.subject.value;
            var id = anchor.substring(1, anchor.length);
            new ORYX.Editor(id);
        });
```
Figure 8: Querying all canvas resources and instantiating an editor instance for each.

Figure 9 queries the triples describing an `oryx:type` property for the current document. The subject of the triples to be queried is therefore a resource with an empty URL, which in every case refers to the current document. The predicate is defined to equal the desired `oryx:type` property, and the object is left undefined. Ideally, this query should return exactly one triple, but since the data manager does not know about the constraints Oryx puts on certain properties, it returns an array in this case, too. In this example, the result is being stored in the `canvasType` variable for further processing. After assuring that there is exactly one such triple, one can access the object's value using `canvasType[0].object.value`.

```
var canvasType = DataManager.query(
    {type: ERDF.RESOURCE, value: ''},
    {prefix: 'oryx', name: 'type'},
    undefined
);
```
Figure 9: Querying the oryx:type property of a canvas.

### Footnotes ###

<sup>1</sup> This particular triple is the second one from figure 1.

<sup>2</sup> This rule is slightly different from the others, since it allows to query for all triples with a certain prefix, without specifying a name. Subjects and objects cannot be queried specifying a type only.

<sup>3</sup> Consider that since this is the last parameter in the method call, the object parameter could have been omitted completely resulting in the same query semantic.


### Bibliography ###

`[1]` Paul V. Biron and Ashok Malhotra. XML Schema Part 2: Datatypes Second Edition. W3c recommendation, W3C, October 2004. http://www.w3.org/TR/xmlschema- 2/.

`[2]` Willi Tscheschner. Oryx - Documentation. Final bachelorâ€™s paper, Hasso Plattner Institute at the University of Potsdam, July 2007.